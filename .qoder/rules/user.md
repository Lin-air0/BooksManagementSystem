---
trigger: always_on
alwaysApply: true
---
# 开发指南

## 理念

### 核心信念
- **渐进式推进，而非一蹴而就**：优先选择可编译、能通过测试的小幅改动
- **向现有代码学习**：先研究、规划，再动手实现
- **务实优先，而非教条主义**：根据项目实际情况灵活调整
- **清晰表意，而非炫技代码**：选择直观、易懂的实现方式，避免过度复杂

### “简洁”的定义
- 每个函数/类仅承担单一职责
- 避免过早抽象（在明确需要前不盲目设计抽象层）
- 不使用“炫技技巧”：优先选择常规、易理解的解决方案
- 若需额外解释才能让人明白，说明代码已过于复杂


## 开发流程

### 1. 规划与阶段拆分
将复杂任务拆分为 3-5 个阶段，在 `IMPLEMENTATION_PLAN.md` 中记录详情：
```markdown
## 第 N 阶段：[阶段名称]
**目标**：[具体可交付成果，如“实现用户登录接口”]
**验收标准**：[可测试的结果，如“输入正确账号密码可返回 token”]
**测试用例**：[具体测试场景，如“测试空密码登录返回 400 错误”]
**状态**：[未开始|进行中|已完成]
```
- 推进过程中及时更新状态
- 所有阶段完成后，移除该文档

### 2. 实现流程
1. **理解**：研究代码库中已有的实现模式（如接口设计、命名规范）
2. **测试**：先编写测试用例（此时测试应处于“失败”状态，即红测）
3. **实现**：编写最小化代码使测试通过（此时测试转为“成功”状态，即绿测）
4. **重构**：在保持测试通过的前提下，优化代码结构（如简化逻辑、统一格式）
5. **提交**：提交代码，提交信息需清晰关联规划文档中的阶段目标

### 3. 遇到瓶颈时的处理（3 次尝试后仍未解决）
**重要规则**：同一问题最多尝试 3 次，若仍无进展，立即停止当前思路。

1. **记录失败信息**：
   - 已尝试的具体方案
   - 完整的错误提示信息
   - 对失败原因的初步分析

2. **研究替代方案**：
   - 查找 2-3 个类似功能的实现案例
   - 记录不同案例采用的解决思路

3. **审视基础逻辑**：
   - 当前的抽象层级是否合适？
   - 能否将问题拆分为更小的子问题？
   - 是否存在更简洁的实现路径？

4. **尝试全新角度**：
   - 是否可使用框架/库的其他特性解决？
   - 是否可更换架构模式（如从“继承”改为“组合”）？
   - 能否通过“移除抽象”而非“增加抽象”解决问题？


## 技术标准

### 架构原则
- **组合优于继承**：通过依赖注入实现功能复用，而非类继承
- **接口优于单例**：采用接口定义行为，提升可测试性与灵活性
- **显式优于隐式**：数据流向、依赖关系需清晰可见，避免“暗箱操作”
- **尽可能测试驱动**：绝不禁用测试用例，若测试失败需修复代码而非跳过测试

### 代码质量
- **每次提交必须满足**：
  - 代码可成功编译/构建
  - 所有现有测试用例通过
  - 新增功能需配套新增测试
  - 符合项目代码格式/代码检查规则

- **提交前需执行**：
  - 运行代码格式化工具/代码检查工具（如 ESLint、Prettier）
  - 自我审查代码改动（检查逻辑漏洞、命名规范性）
  - 确保提交信息说明“改动原因”（而非仅描述“改了什么”）

### 错误处理
- 快速失败（Fail Fast）：尽早抛出错误，并附带描述性信息
- 错误信息需包含上下文（如“用户 ID: 123 查找失败”），便于调试
- 在合适的层级处理错误（如业务层处理业务逻辑错误，接口层处理请求参数错误）
- 绝不静默吞掉异常（禁止无处理逻辑的 `try-catch`）


## 决策框架
当存在多种可行方案时，按以下优先级选择：
1. **可测试性**：该方案是否易于编写测试用例？
2. **可读性**：6 个月后他人能否快速理解该代码？
3. **一致性**：是否与项目现有实现模式保持一致？
4. **简洁性**：是否为“能解决问题的最简单方案”？
5. **可逆转性**：后续若需修改，成本是否较低？


## 项目集成

### 熟悉代码库的方法
- 找到 3 个与目标功能类似的现有模块/组件
- 总结项目通用模式（如 API 设计风格、状态管理方式）
- 优先使用项目已引入的库/工具类，避免重复造轮子
- 遵循现有测试框架的编写规范

### 工具使用
- 使用项目已配置的构建系统（如 Maven、Webpack）
- 采用项目指定的测试框架（如 Jest、JUnit）
- 遵循项目的代码格式化/代码检查配置（不随意修改规则）
- 引入新工具前需提供充分理由（如“现有工具无法满足 XX 需求”）


## 质量门禁

### 完成标准（Definition of Done）
- [ ] 测试用例已编写且全部通过
- [ ] 代码符合项目编码规范
- [ ] 无代码检查/格式化工具警告
- [ ] 提交信息清晰描述改动原因
- [ ] 实现结果与规划文档一致
- [ ] 所有 TODO 注释均关联Issue编号（无无归属的待办事项）

### 测试指南
- 测试“行为”而非“实现细节”（如测试“登录成功返回 token”，而非“调用了 XX 函数”）
- 尽可能保证每个测试用例仅包含一个断言（便于定位失败原因）
- 测试用例名称需清晰描述场景（如“test_empty_password_returns_400”，而非“test_login_1”）
- 复用项目已有的测试工具类/辅助函数
- 测试用例需具备确定性（相同输入始终产生相同输出，避免随机结果）


## 重要提醒

**绝对禁止**：
- 使用 `--no-verify` 绕过提交钩子（如代码检查、测试验证）
- 禁用测试用例而非修复测试失败问题
- 提交无法编译/构建的代码
- 凭假设开发，需通过查看现有代码验证逻辑

**必须遵守**：
- 以“可运行的小幅改动”为单位提交代码（避免一次性提交大量未验证代码）
- 推进过程中及时更新规划文档状态
- 从现有实现中学习，而非盲目创新
- 3 次尝试失败后立即停止当前思路，重新审视问题